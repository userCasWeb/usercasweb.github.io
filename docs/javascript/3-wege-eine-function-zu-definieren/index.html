<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAppDev</title>
    <link rel="preconnect" href="https://fonts.googleapis.com"> 
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
    <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="container">
    <header>
      <a class="s-logo" href="/">WebAppDev</a>
      <nav class="navi">
        <a class="menu-btn" href="/javascript"><span>01</span>Javascript</a>
        <a class="menu-btn" href="/html"><span>02</span>Html</a>
        <a class="menu-btn" href="/css"><span>03</span>Css</a>
      </nav>
    </header>  <h1 class="center padding-top-4">3 Wege eine Function zu definieren</h1>
  <p class="center dateTag"><span>7.3.2020 @ javascript</span></p>
  <main class="padding-col-0-14 padding-top-2">
  <p>Um eine Function zu definieren gibt es in Javascript 3 grundsätzliche verschiedene Möglichkeiten. Je nach Situation und Preferenz eignet sich die eine Art besser oder schlechter. Dann wird noch kurz das Return Statement angeschaut und am Schluss noch kurz die Arguments.</p>
<h2 id="1-function-definition">1. Function Definition</h2>
<h3 id="function-declaration">Function Declaration</h3>
<p>Die erste Möglichkeit besteht darin, mit dem Keyword <code>function</code> die Function zu deklarieren. So als würde man eine Variable mit dem Keyword <code>var</code> deklarieren. Dabei geben wir der Function einen Namen. Im Beispiel unten ist es <code>square</code>. </p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> x * x;
}</code></pre>

<h3 id="function-expression">Function Expression</h3>
<p>Als zweitens kann die Function als <strong>Expression</strong> definieren werden. Dabei wird einer Variablen gleich die Function angehängt oder bestimmt. Wir geben aber der Function keinen Namen. Sonder speichern diese in einer Variablen, in diesem Fall auch <code>square</code>.</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> square = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> x * x;
}</code></pre>

<h3 id="arrow-function-expression">Arrow Function Expression</h3>
<p>Neu kann eine Function auch mit einem <code>=&gt;</code> (gleich grösser Zeichen) definiert werden. Dieses Zeichen nennt man auch <strong>Fat Arrow</strong>. Manchmal wird diese Function auch Fat Arrow Function genannt. Es ist das gleiche Prinzip wie bei der Function Expression nur, dass das Keyword <code>function</code> weggelassen werden kann und die Paratemer vor der Fat Arrow geschrieben wird. </p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> x * x;
}</code></pre>

<h2 id="2-the-return-statement">2. The return statement</h2>
<p>Bei allen 3 Definitionen ist ein <strong>return statement</strong> im <strong>function body</strong>. Dieses statement ist notwendig um das Resultat der function zurückzugeben. Dieses statement kann aber auch bei einer <strong>Arrow Function</strong> weggelassen werden. Dazu mehr in einem anderen Beitrag. Wenn wir das return statement wegglassen und dafür eine Konstante definieren, wird beim Aufruf der Function undefined zurückgegeben.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">const</span> a = x * x;
}
square(<span class="hljs-number">9</span>); <span class="hljs-comment">// -&gt; undefined</span></code></pre>

<p>Mit dem Aufruf des Function Name <code>square</code> ohne Klammern <code>()</code> wird die Function selber zurückgegeben. Man gibt keine Argumente mit. </p>
<pre><code class="hljs js"><span class="hljs-comment">// Function Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> x * x;
}
square; <span class="hljs-comment">// -&gt; f square(x) {return x * x;}</span>

<span class="hljs-comment">// Function Expression </span>
<span class="hljs-keyword">const</span> square = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> x * x;
}
square; <span class="hljs-comment">// -&gt; f (x) {return x * x;}</span>

<span class="hljs-comment">// Arrow Function Expression</span>
<span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> x * x;
}
square; <span class="hljs-comment">// -&gt; f (x) {return x * x;}</span></code></pre>

<h2 id="3-too-many-or-too-few-arguments">3. Too many or too few arguments</h2>
<p>Wenn wir aber nicht alle <strong>arguments</strong> beim Aufruf der <strong>function</strong> mitgeben, wird ein NaN zurückgegeben. Je Nachdem wird auch ein undefinet zurückgegeben. Wenn ein Argument zuviel mitgegeben wird, wird dieser ignoriert.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">surface</span>(<span class="hljs-params">x, y</span>) </span>{
  <span class="hljs-keyword">return</span> x * y;
}
surface(); <span class="hljs-comment">// -&gt; Nan</span>
surface(<span class="hljs-number">4</span>); <span class="hljs-comment">// -&gt; NaN</span>
surface(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// -&gt; 20</span>
surface(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">// -&gt; 20</span></code></pre>

<p>Hier noch ein Beispiel mit Strings. Hier wird bei einem fehlenden Argument undefined zurückgegeben, aber der erste Wert wird zurückgegeben.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concate</span>(<span class="hljs-params">x. y</span>) </span>{
  <span class="hljs-keyword">return</span> x + y;
}
concate(); <span class="hljs-comment">// -&gt; NaN</span>
concate(<span class="hljs-string">"Hallo "</span>); <span class="hljs-comment">// -&gt; Hallo undefined</span>
concate(<span class="hljs-string">"Hallo "</span>, <span class="hljs-string">"World "</span>); <span class="hljs-comment">// -&gt; Hello World</span>
concate(<span class="hljs-string">"Hallo "</span>, <span class="hljs-string">"World "</span>, <span class="hljs-string">"we love you"</span>); <span class="hljs-comment">// -&gt; Hello World</span></code></pre>
  </main>
    <script>
        const list = document.getElementsByClassName('menu-btn');
        const domain = window.location.protocol + '//' + window.location.host;
        const adress = window.location.href.replace(domain,'');
        let current = 0;
        for (let i = 0; i < list.length; i++) {
            if (adress.search(list[i].getAttribute('href')) === 0) {
                current = i;
                list[current].className = 'menu-btn active';    
            };
        };
    </script>
    </body>
</html>	
